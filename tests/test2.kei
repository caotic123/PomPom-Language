Static nat : *.
Static bool : *.
Static Z : nat.
Static S : ~ {nat :: | Z | S} ~> nat.

Succ 
  |x :: ~ Nat ~> {nat :: | S} => (S x).

Static unit : *.
Static I : unit.

Unit
  {unit :: |I}.

False
  {unit :: }.

⊥ |x H :: (Prop : *) ~ False ~> Prop => [H of x].

Static or : ~ * ~> ~ * ~> *.

Static or_right : (x : *) (y : *) ~ x ~> (or x y).
Static or_left : (x : *) (y : *) ~ y ~> (or x y).

Or 
  |A B :: ~ * ~> ~ * ~> * => {(or A B) :: |or_right | or_left}.

Static Neg : ~ * ~> *.
Static Not : (A : *) ~ (~ A ~> False) ~> (Neg A).

Negation | A :: ~ * ~> * =>
  {(Neg A) :: |Not}.

neg_elim
   |A H a :: (A : *) ~ (Negation A) ~> ~ A ~> False => [H of False
      |(Not _ f) => (f a)
   ].

Static bool : *.
Static true : bool.
Static false : bool.

Static Pair : ~ * ~> ~ * ~> *.
Static MkPair : (A : *) (B : *) ~> ~ A ~> ~ B ~> (Pair A B).

AxB
  |A B :: ~ * ~> ~ * ~> * => {(Pair A B) :: |MkPair}.

first
  |A B pair :: (A : *) (B : *) (pair : (AxB A B)) A => [pair of A
    |(MkPair _ _ v v') => v
  ].

second
  |A B pair :: (A : *) (B : *) (pair : (AxB A B)) B => [pair of B
    |(MkPair _ _ v v') => v'
  ].

Bool
  {bool :: |true |false}.

isSucc
  |n :: ~ Nat ~> * => [n of *
     |(S _) => Unit
     |Z => False
  ]. 

Static ≡ : (A : *) ~> ~ A ~> ~ A ~> *.
Static refl : (A : *) ~> (n : A) ~> (≡ A n n).


Eq | Set x y :: (A : *) (x : A) (y : A) ~> *  
  => {(≡ Set x y) :: |refl}.

eq_rect
 | h x y P H proof :: 
                      (H : *)
                      (x : H)
                      (y : H)
                      (P : (~ H ~> *))
                      ~ (Eq H x y) ~> 
                      ~ (P x) ~>
                        (P y) => 
   [
      H of (P y)
        |(refl _ x') => proof
   ].

bool_false | H :: ~ (Eq Bool true false) ~> False => 
     def Bool→* = |b :: ~ Bool ~> * => [b of *
        |true => Unit
        |false => False
     ];
     (eq_rect Bool true false Bool→* H I).

rewrite
  | A P x y H H1 :: (A : *) (P : ~ A ~> *) (x : A) (y : A) (H : {(≡ A x y) :: | refl})
     (H1 : (P x)) ~> (P y) => [H of (P y)
   |(refl a' x') => H1
].

rewrite' 
  | A x y z H H' :: (A : *) 
                    (x : A) ~>
                    (y : A) ~>
                    (z : A) ~>
                    (H : {(≡ A x y) :: |refl}) ~>
                    (H' : {(≡ A y z) :: |refl}) ~> 
                    {(≡ A x z) :: |refl} => 
  [H' of {(≡ A x z) :: |refl}
   |(refl a' x') => H
].

cong
 | h x y Prop P H  :: 
                 (H : *)
                 (x : H)
                 (y : H)
                 (Prop : *)
                 (P : ~ H ~> Prop)
                 (eq : {(≡ H x y) :: | refl})
                 {(≡ Prop (P x) (P y)) :: | refl}
  => [
      H of {(≡ Prop (P x) (P y)) :: |refl}
        |(refl _ x') => (refl Prop (P x'))
     ].

symmetry
  | h x y H :: (h : *) ~> (x : h) ~> (y : h) ~> ~ {(≡ h x y) :: | refl} ~> {(≡ h y x) :: | refl} =>
 [H of {(≡ h y x) :: | refl}
   |(refl _ x') => (refl h x')
 ].

Nat
  {nat :: | Z | S}.
+ 
 | n y :: ~ Nat ~> ~ Nat ~> Nat => [n of Nat
  |Z => y
  |(S x) => (S (+ x y))
].

zero_identity_plus' 
  | x :: (x : Nat) ~> {(≡ nat x (+ x Z)) :: |refl} => [x of {(≡ nat x (+ x Z)) :: |refl}
    |Z => (refl nat Z)
    |(S x') => (cong nat x' (+ x' Z) nat S (zero_identity_plus' x'))
   ].

Static list : ~ * ~> *.
Static empty : (A : *) (list A).
Static new : (A : *) ~ A ~> ~ {(list A) :: |new |empty} ~> (list A).

List
  | A :: ~ * ~> * => {(list A) :: |new |empty }.

NonEmpty 
  |A :: ~ * ~> * => {(list A) :: |new}.

insert_at 
  |A ls v at :: (A : *) ~ (List A) ~> ~ A ~> ~ Nat ~> (NonEmpty A) => [at of (NonEmpty A)
    |Z => (new A v ls)
    |(S x) => [ls of (NonEmpty A)
      |(empty _) => (new A v (empty A))
      |(new _ head tail) => (new A head (insert_at A tail v x))
    ]
  ].

length 
  |A ls :: (A : *) ~> ~ (List A) ~> Nat => [ls of Nat
    |(empty _) => Z
    |(new A head tail) => (S (length A tail))
  ].

last 
  |A ls :: (A : *) ~> ~ (NonEmpty A) ~> A => [ls of A
    |(new A head tail) => [tail of A
      |(empty _) => head
      |(new A head2 tail2) => (last A (new A head2 tail2))
    ]
  ].

works_fine
  def my_list_not_empty = ((new Nat Z (empty Nat)) :: (NonEmpty Nat));
  (length Nat my_list_not_empty).

Static vector : ~ * ~> (x : Nat) *.
Static nil : (A : *) (vector A Z).
Static cons : (A : *) (x : Nat) (y : A) (H : {(vector A x) :: |nil |cons}) (vector A (S x)).

Vector
 | A n :: (A : *) ~> ~ Nat ~> * => {(vector A n) :: |nil |cons}.

concat 
 | A n m k x y z :: (A : *) (n : Nat) (m : Nat) (k : Nat)
    ~ (Vector A n) ~> ~ (Vector A m) ~> ~ (Vector A k) ~> (Vector A k) => [z of (Vector A k)
   |(nil _) => (nil _)
   |(cons A pred head tail) => (cons A pred head tail) 
 ].

left_succ_nat | x y :: (x : Nat) ~> (y : Nat) ~> {(≡ nat (+ x (S y)) (S (+ x y))) :: | refl } => 
  [x of {(≡ nat (+ x (S y)) (S (+ x y))) :: | refl}
    |Z => (refl nat (S y))
    |(S x') => (cong nat (+ x' (S y)) (S (+ x' y)) nat S (left_succ_nat x' y))
  ].

x+y≡y+x
 | x y :: (x : Nat) (y : Nat) * => {(≡ nat (+ x y) (+ y x)) :: | refl}.

+_com 
  | x y :: (x : Nat) (y : Nat) (x+y≡y+x x y) => [x of (x+y≡y+x x y)
    |Z => 
      def y≡y+0 = (zero_identity_plus' y);
      (rewrite' nat y y (+ y Z) (refl nat y) y≡y+0)
    |(S n) => 
       def x≡y→x+1≡y+1 = (cong nat (+ n y) (+ y n) nat S (+_com n y));
       def x+1+y≡x+y+1 = (symmetry nat (+ y (S n)) (S (+ y n)) (left_succ_nat y n));
       (rewrite' nat (S (+ n y)) (S (+ y n)) (+ y (S n)) x≡y→x+1≡y+1 x+1+y≡x+y+1)
  ].

gte
  | x y :: ~ Nat ~> ~ Nat ~> Bool => [x of Bool
  |Z => [
    y of Bool
      |Z => true
      |(S x') => false
  ]
  |(S x') => [
    y of Bool
      |Z => true
      |(S y') => (gte x' y')
  ]
].

gt 
  | x y :: ~ Nat ~> ~ Nat ~> Bool => [x of Bool
  |Z => [
    y of Bool
      |Z => false
      |(S x') => false
  ]
  |(S x') => [
    y of Bool
      |Z => true
      |(S y') => (gt x' y')
  ]
].

eql 
 | x y :: ~ Nat ~> ~ Nat ~> Bool => [x of Bool
  |Z => [
    y of Bool
      |Z => true
      |(S x') => false
  ]
  |(S x') => [
    y of Bool
      |Z => false
      |(S y') => (eql x' y')
  ]
].

eql_prop
  | x y H :: (x : Nat) (y : Nat) ~ (Eq Bool (eql x y) true) ~> (Eq Nat x y) => 
  [x of (Eq Nat x y)
    |Z => [y of (Eq Nat x y)
       |Z => (refl Nat Z)
       |(S n) => (⊥ (Eq Nat x y) (bool_false (symmetry Bool false true H)))
    ]
    |(S n) => [y of (Eq Nat x y)
       |Z =>  (⊥ (Eq Nat x y) (bool_false (symmetry Bool false true H)))
       |(S n') => (cong Nat n n' Nat Succ (eql_prop n n' H))
    ]
  ].

unique_eql 
  | x :: (x : Nat) ~> (Eq Bool (eql x x) true) =>
    [x of (Eq Bool (eql x x) true)
      |Z => (refl Bool true)
      |(S n) => (unique_eql n)
    ].

eql_neg_prop
  | x y H H1 :: (x : Nat) (y : Nat) (H : (Eq Bool (eql x y) false)) (H1 : (Eq Nat x y)) ~> False => 
  [H1 of False
    |(refl _ z) => (bool_false (symmetry Bool false true (rewrite' Bool false (eql z z) true (symmetry Bool (eql z z) false H) (unique_eql z))))
  ].

nat_dec
  |x y :: (x : Nat) (y : Nat) (Or (Eq Nat x y) (Negation (Eq Nat x y))) => [
  (eql x y) of (Or (Eq Nat x y) (Negation (Eq Nat x y)))
    |true => (or_right (Eq Nat x y) (Negation (Eq Nat x y)) (eql_prop x y (refl Bool true)))
    |false => (or_left (Eq Nat x y) (Negation (Eq Nat x y)) (Not (Eq Nat x y) (eql_neg_prop x y (refl Bool (eql x y)))))
].

insert_sort 
 | xs v :: ~ (List Nat) ~> ~ Nat ~> (NonEmpty Nat) => 
  [xs of (NonEmpty Nat)
     |(empty _) => (new Nat v (empty Nat))
     |(new _ head tail) => [(gte head v) of (NonEmpty Nat)
       |false => (new _ head (insert_sort tail v))
       |true => (new _ v (new _ head tail))
     ]
  ].

sort 
 |xs :: ~ (List Nat) ~> (List Nat) =>
  [xs of (List Nat)
    |(empty _) => (empty _)
    |(new _ head tail) => (insert_sort (sort tail) head)
  ].

1 
 (S Z).

test_sort 
  def list = (new Nat 1 (new Nat (S 1) (empty Nat)));
  def ordened_list = (sort (new Nat (S 1) (new Nat 1 (empty Nat))));
  ((refl (List Nat) (sort list)) :: (Eq (List Nat) (sort list) ordened_list)).

or 
  | x y :: ~ Bool ~> ~ Bool ~> Bool => [x of Bool
    |true => true
    |false => y
  ].

sorted 
 |xs :: ~ (List Nat) ~> * => [xs of *
    |(empty _) => Unit
    |(new _ head tail) => [tail of *
       |(empty _) => (sorted tail)
       |(new _ head2 tail2) => (AxB (Eq Bool (gte head2 head) true) (sorted tail))
    ]
  ].

false≠true
  |H :: ~ (Eq Bool true false) ~> False => 
    def absurd_hyp = |x :: ~ Bool ~> * => [x of *
      |true => Unit
      |false => False
    ];
    (eq_rect Bool true false absurd_hyp H I).

gte_inverse 
  | x y H :: (x : Nat) (y : Nat) ~ (Eq Bool (gte x y) false) ~> (Eq Bool (gte y x) true) =>
    [x of (Eq Bool (gte y x) true)
      |Z => [y of (Eq Bool (gte y x) true)
        |Z => (refl Bool true)
        |(S n) => (refl Bool true)
      ]
      |(S n) => [y of (Eq Bool (gte y (S n)) true)
        |Z =>  (⊥ (Eq Bool (gte Z (S n)) true) (false≠true H))
        |(S m) => (gte_inverse n m H)
      ]
  ]. 

gte_transitivy
  | x y z H H2 :: (x : Nat) (y : Nat) (z : Nat)
     ~ (Eq Bool (gte x y) true) ~> ~ (Eq Bool (gte y z) true) ~> (Eq Bool (gte x z) true) => [x of (Eq Bool (gte x z) true)
       |Z => [z of (Eq Bool (gte x z) true)
         |Z => (refl Bool true)
         |(S m) => [y of (Eq Bool (gte x z) true)
           |Z => H2
           |(S n) => H
         ]
       ]
       |(S n) => [z of (Eq Bool (gte x z) true)
         |Z => (refl Bool true)
         |(S m) => [y of (Eq Bool (gte x z) true)
           |Z => (⊥ (Eq Bool (gte x z) true) (false≠true (symmetry Bool false true H2)))
           |(S s) => (gte_transitivy n s m H H2)
         ]
       ]
     ].

 neg_eq_symmetry 
   |A x y H :: (A : *) (x : A) (y : A) (H : (Negation (Eq A x y))) ~> (Negation (Eq A y x)) => [H of (Negation (Eq A y x))
    |(Not _ map) => (Not (Eq A y x) |i :: ~ (Eq A y x) ~> False => (map (symmetry A y x i)))
   ].
