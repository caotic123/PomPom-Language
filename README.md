# The-cute-FormCore

This is just a cute implemenation of a self dependently typed language based on Formcore[https://github.com/moonad/FormCoreJS/blob/master/FormCore.js], it is not our purpose fully copy the formcore nor Kind, our goal is just to provide a semi-automate proof asssisant based on formcore, and by consequence self types encondings[https://homepage.divms.uiowa.edu/~astump/papers/fu-stump-rta-tlca-14.pdf].

# Self types

[Open MANIFESTO]
Before I was present to self types I was just having fun with martin-lof type theory (like Coq) and first order dependent type theory (here i am talking specially about λΠ-calculus), then after taking a time searching a dependent language which have less complexivty in your core i finnaly found the Kind Language[https://github.com/uwu-tech/Kind]. 

##### But why self-types?
For me (and I am not alone lol) being minimal means less complexity and finally less susceptibility to bugs, even though having nice algorithms to make the life of a mathematician/programmer easier is a crucial feature, a humongous core can destroy the reliableness of your language. If you have a monstrous core who will have the courage to check every line of code? Nevertheless, whether you find this person or not, you will trust him/her/they?

In the state of art, we have few options to pick up of dependently typed implementations (i am rejecting type theories that have not been tested/implemented). If you consider the minimal implementations this set is even small. The most know core is the calculus of constructions, it is based on martin-lof type theory and Coquand work. Despite Coc is minimal it is incomplete in the sense of inductive definitions, in fact (as every lambda-calculus) Coc can represent algebraic recursive data, however, typing them is a little more complex. When you are working with dependent constructions it will probably derive into two options: unification or elimination pattern, the first is normally generated by the compiler based on assumptions of a dependent pattern matching, and the second is normally generated by the construction of definition/proof. 

Coc has not a unification (not meaning the convertibility of beta-reduction or another reducer), so to have a complete proof assistant the Coc was extended with inductive definitions which normally come with a unification algorithm (Some proofs assistants like Agda have more of one unification algorithm). But having a unification algorithm (dependent matching) has a cost (and it cost a lot), first, this kind of algorithm often unifies what the programmer does not expect to be unified, the "free" axioms come with naive implementations of unification, for example, the K axiom or the injection of constructors. These axioms are related to an infinity cause of problems, some can be incompatible with another kind of logic (the K axiom with homotopy type theory) or even be inconsistent in some context (the injection of the constructor). The second principal cost of having a unification algorithm is the complexity of implementing it, as we know naive implementations can lead to some big problems, so what rest of this is a complex unification algorithm. 

##### Unification is cute too
Talking about unification like this seems like dependent pattern matching is bad which of course is not true. The Agda language has a safe version of the unification algorithm free of K axiom based on the Jesper work. Furthermore, pattern matching with unification makes the life of the programmer easier, compared to pure eliminators, pattern matching is easier to use and can adapt to receive safe extensions (like the detection absurd case, circle case, etc...), so unification normally removes trivial proofs obligations. Moreover, having support to the K axiom does not make your language worse or better than another language, the axiom K has the benefit to destroy opaques proofs, so if you need a reflexivity proof between two proofs by computation you can work with Streicher K axiom. Finally, implementing is not always complex, once you can implement a safe naive version, for example, Kei is a language that I implemented with the old version of the Agda unification algorithm which is pretty easy to reproduce and has a powerful dependent pattern matching.

##### Is just a question of tradeoff
Unification makes the language more easy to use, and eliminators are more easy to predict. So, answering my question this project uses self types because it aims to be easy to implement and easy to predict.

##### Self definitions vs builtin inductive data
Another point to notice about self types is that they represent data as a function. I am not saying type constructors as in Agda does not act as function, but at the term level, you cannot construct data using a lambda abstraction like in self types, and this is not just a point of simplicity, but also a point of expressibility. For example, to Kind have induction they do not need to extend with some other abstraction, lambda was just enough. It comes with a question: "If lambda is powerful enough why not use this to express inductive data?". Of course, besides that using lambda as inductive data also comes with problems. Even if self-types are easier to predict than another type theory based on some unification algorithm, *in my opinion,* builtin inductive data are easier to predict than pure lambdas (for me because built-in inductive data was constructed to be used *only* as inductive data, here we present again the program vs data dilemma). A good example is consider a language with bultin inductive data type and self types :

```
Nat 
  self(P : ~ Nat -> Type) -> ~ (P Z) -> (ind : (n : Nat) -> ~ (P n) -> (P (S n))) -> (P self).
 
Z : Nat 
  ....

S : Nat
  ...
 
nat : Set
  z : nat
  s : nat -> Nat
```

Could we say that?

```
Z = z
S = s
Nat = nat
```

In terms of the definition of equality, probably no. Furthermore, the strong nominality of the built-in inductive data type will not accept this kind of assertion. Finally, in a homotopy theory view, a path could be construed between the two nats, but would be possible to define between the two constructors?

###### For me, it just a question of what gives me less headache.
And it needs to still useful, so welcome self-types, Qed.



